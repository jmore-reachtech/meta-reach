From 5839d398c808f924607b3bbe56f4a52a69e6d5e6 Mon Sep 17 00:00:00 2001
From: Jeff Horn <jhorn@reachtech.com>
Date: Thu, 14 Nov 2013 16:11:29 -0800
Subject: [PATCH] Fix for eGalax and Penmount

Signed-off-by: Jeff Horn <jhorn@reachtech.com>
---
 plugins/input-raw.c | 170 ++++++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 139 insertions(+), 31 deletions(-)

diff --git a/plugins/input-raw.c b/plugins/input-raw.c
index 9659eac..0fe584f 100644
--- a/plugins/input-raw.c
+++ b/plugins/input-raw.c
@@ -18,6 +18,7 @@
 
 #include <errno.h>
 #include <stdio.h>
+#include <limits.h>
 
 #include <stdlib.h>
 #ifdef HAVE_UNISTD_H
@@ -30,9 +31,23 @@
 #ifndef EV_SYN /* 2.4 kernel headers */
 # define EV_SYN 0x00
 #endif
+#ifndef EV_CNT
+# define EV_CNT (EV_MAX+1)
+#endif
+#ifndef ABS_CNT
+# define ABS_CNT (ABS_MAX+1)
+#endif
+#ifndef KEY_CNT
+# define KEY_CNT (KEY_MAX+1)
+#endif
 
 #include "tslib-private.h"
 
+#define GRAB_EVENTS_WANTED	1
+#define GRAB_EVENTS_ACTIVE	2
+
+#define EV_VERSION_TSLIB	0x10000
+
 struct tslib_input {
 	struct tslib_module_info module;
 
@@ -42,29 +57,75 @@ struct tslib_input {
 
 	int	sane_fd;
 	int	using_syn;
+	int	grab_events;
 };
 
+#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
+#define BIT(nr)                 (1UL << (nr))
+#define BIT_MASK(nr)            (1UL << ((nr) % BITS_PER_LONG))
+#define BIT_WORD(nr)            ((nr) / BITS_PER_LONG)
+#define BITS_PER_BYTE           8
+#define BITS_PER_LONG           (sizeof(long) * BITS_PER_BYTE)
+#define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
+
 static int check_fd(struct tslib_input *i)
 {
 	struct tsdev *ts = i->module.dev;
 	int version;
-	u_int32_t bit;
-	u_int64_t absbit;
-
-	if (! ((ioctl(ts->fd, EVIOCGVERSION, &version) >= 0) &&
-		(version == EV_VERSION) &&
-		(ioctl(ts->fd, EVIOCGBIT(0, sizeof(bit) * 8), &bit) >= 0) &&
-		(bit & (1 << EV_ABS)) &&
-		(ioctl(ts->fd, EVIOCGBIT(EV_ABS, sizeof(absbit) * 8), &absbit) >= 0) &&
-		(absbit & (1 << ABS_X)) &&
-		(absbit & (1 << ABS_Y)) && (absbit & (1 << ABS_PRESSURE)))) {
-		fprintf(stderr, "selected device is not a touchscreen I understand\n");
+	long evbit[BITS_TO_LONGS(EV_CNT)];
+	long absbit[BITS_TO_LONGS(ABS_CNT)];
+	long keybit[BITS_TO_LONGS(KEY_CNT)];
+
+	if (ioctl(ts->fd, EVIOCGVERSION, &version) < 0) {
+		fprintf(stderr, "tslib: Selected device is not a Linux input event device\n");
 		return -1;
 	}
 
-	if (bit & (1 << EV_SYN))
+	if (version > EV_VERSION) {
+		fprintf(stderr, "tslib: Selected device uses a different version of the event protocol than tslib was compiled for\n");
+		return -1;
+	}
+
+	if ( (ioctl(ts->fd, EVIOCGBIT(0, sizeof(evbit)), evbit) < 0) ||
+		!(evbit[BIT_WORD(EV_ABS)] & BIT_MASK(EV_ABS)) ||
+		!(evbit[BIT_WORD(EV_KEY)] & BIT_MASK(EV_KEY)) ) {
+		fprintf(stderr, "tslib: Selected device is not a touchscreen (must support ABS and KEY event types)\n");
+		return -1;
+	}
+
+	if ((ioctl(ts->fd, EVIOCGBIT(EV_ABS, sizeof(absbit)), absbit)) < 0 ||
+		!(absbit[BIT_WORD(ABS_X)] & BIT_MASK(ABS_X)) ||
+		!(absbit[BIT_WORD(ABS_Y)] & BIT_MASK(ABS_Y))) {
+		fprintf(stderr, "tslib: Selected device is not a touchscreen (must support ABS_X and ABS_Y events)\n");
+		return -1;
+	}
+
+	/* Since some touchscreens (eg. infrared) physically can't measure pressure,
+	the input system doesn't report it on those. Tslib relies on pressure, thus
+	we set it to constant 255. It's still controlled by BTN_TOUCH - when not
+	touched, the pressure is forced to 0. */
+
+	if (!(absbit[BIT_WORD(ABS_PRESSURE)] & BIT_MASK(ABS_PRESSURE))) {
+		i->current_p = 255;
+
+		if ((ioctl(ts->fd, EVIOCGBIT(EV_KEY, sizeof(keybit)), keybit) < 0) ||
+			!(keybit[BIT_WORD(BTN_TOUCH)] & BIT_MASK(BTN_TOUCH)) ) {
+			fprintf(stderr, "tslib: Selected device is not a touchscreen (must support BTN_TOUCH events)\n");
+			return -1;
+		}
+	}
+
+	if (evbit[BIT_WORD(EV_SYN)] & BIT_MASK(EV_SYN))
 		i->using_syn = 1;
 
+	if (i->grab_events == GRAB_EVENTS_WANTED) {
+		if (ioctl(ts->fd, EVIOCGRAB, (void *)1)) {
+			fprintf(stderr, "tslib: Unable to grab selected input device\n");
+			return -1;
+		}
+		i->grab_events = GRAB_EVENTS_ACTIVE;
+	}
+
 	return 0;
 }
 
@@ -76,6 +137,7 @@ static int ts_input_read(struct tslib_module_info *inf,
 	struct input_event ev;
 	int ret = nr;
 	int total = 0;
+	int pen_up = 0;
 
 	if (i->sane_fd == 0)
 		i->sane_fd = check_fd(i);
@@ -90,35 +152,35 @@ static int ts_input_read(struct tslib_module_info *inf,
 				total = -1;
 				break;
 			}
-	
+
 			switch (ev.type) {
 			case EV_KEY:
 				switch (ev.code) {
 				case BTN_TOUCH:
-					if (ev.value == 0) {
-						/* pen up */
-						samp->x = 0;
-						samp->y = 0;
-						samp->pressure = 0;
-						samp->tv = ev.time;
-						samp++;
-						total++;
-					}
+					if (ev.value == 0)
+						pen_up = 1;
 					break;
 				}
 				break;
 			case EV_SYN:
 				/* Fill out a new complete event */
-				samp->x = i->current_x;
-				samp->y = i->current_y;
-				samp->pressure = i->current_p;
+				if (pen_up) {
+					samp->x = 0;
+					samp->y = 0;
+					samp->pressure = 0;
+					pen_up = 0;
+				} else {
+					samp->x = i->current_x;
+					samp->y = i->current_y;
+					samp->pressure = i->current_p;
+				}
 				samp->tv = ev.time;
 	#ifdef DEBUG
 				fprintf(stderr, "RAW---------------------> %d %d %d %d.%d\n",
 						samp->x, samp->y, samp->pressure, samp->tv.tv_sec,
 						samp->tv.tv_usec);
-	#endif		 /*DEBUG*/
-					samp++;
+	#endif /* DEBUG */
+				samp++;
 				total++;
 				break;
 			case EV_ABS:
@@ -140,7 +202,7 @@ static int ts_input_read(struct tslib_module_info *inf,
 	} else {
 		unsigned char *p = (unsigned char *) &ev;
 		int len = sizeof(struct input_event);
-	
+
 		while (total < nr) {
 			ret = read(ts->fd, p, len);
 			if (ret == -1) {
@@ -149,7 +211,7 @@ static int ts_input_read(struct tslib_module_info *inf,
 				}
 				break;
 			}
-	
+
 			if (ret < (int)sizeof(struct input_event)) {
 				/* short read
 				 * restart read to get the rest of the event
@@ -159,7 +221,7 @@ static int ts_input_read(struct tslib_module_info *inf,
 				continue;
 			}
 			/* successful read of a whole event */
-	
+
 			if (ev.type == EV_ABS) {
 				switch (ev.code) {
 				case ABS_X:
@@ -192,7 +254,7 @@ static int ts_input_read(struct tslib_module_info *inf,
 	#ifdef DEBUG
 				fprintf(stderr, "RAW---------------------------> %d %d %d\n",
 					samp->x, samp->y, samp->pressure);
-	#endif	 /*DEBUG*/
+	#endif /* DEBUG */
 				samp++;
 				total++;
 			} else if (ev.type == EV_KEY) {
@@ -222,6 +284,15 @@ static int ts_input_read(struct tslib_module_info *inf,
 
 static int ts_input_fini(struct tslib_module_info *inf)
 {
+	struct tslib_input *i = (struct tslib_input *)inf;
+	struct tsdev *ts = inf->dev;
+
+	if (i->grab_events == GRAB_EVENTS_ACTIVE) {
+		if (ioctl(ts->fd, EVIOCGRAB, (void *)0)) {
+			fprintf(stderr, "tslib: Unable to un-grab selected input device\n");
+		}
+	}
+
 	free(inf);
 	return 0;
 }
@@ -231,6 +302,36 @@ static const struct tslib_ops __ts_input_ops = {
 	.fini	= ts_input_fini,
 };
 
+static int parse_raw_grab(struct tslib_module_info *inf, char *str, void *data)
+{
+	struct tslib_input *i = (struct tslib_input *)inf;
+	unsigned long v;
+	int err = errno;
+
+	v = strtoul(str, NULL, 0);
+
+	if (v == ULONG_MAX && errno == ERANGE)
+		return -1;
+
+	errno = err;
+	switch ((int)data) {
+	case 1:
+		if (v)
+			i->grab_events = GRAB_EVENTS_WANTED;
+		break;
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+static const struct tslib_vars raw_vars[] =
+{
+	{ "grab_events", (void *)1, parse_raw_grab },
+};
+
+#define NR_VARS (sizeof(raw_vars) / sizeof(raw_vars[0]))
+
 TSAPI struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
 {
 	struct tslib_input *i;
@@ -245,5 +346,12 @@ TSAPI struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
 	i->current_p = 0;
 	i->sane_fd = 0;
 	i->using_syn = 0;
+	i->grab_events = 0;
+
+	if (tslib_parse_vars(&i->module, raw_vars, NR_VARS, params)) {
+		free(i);
+		return NULL;
+	}
+
 	return &(i->module);
 }
-- 
1.8.1.2

