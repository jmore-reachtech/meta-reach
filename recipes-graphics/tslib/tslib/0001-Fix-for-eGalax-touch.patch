From 5a980b20103e9d33300c9c09a45214d985ce4464 Mon Sep 17 00:00:00 2001
From: Jeff Horn <jhorn@reachtech.com>
Date: Wed, 6 Nov 2013 09:40:52 -0800
Subject: [PATCH] Fix for eGalax touch

Signed-off-by: Jeff Horn <jhorn@reachtech.com>
---
 plugins/input-raw.c | 82 +++++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 70 insertions(+), 12 deletions(-)

diff --git a/plugins/input-raw.c b/plugins/input-raw.c
index b8d68d1..2fe7cee 100644
--- a/plugins/input-raw.c
+++ b/plugins/input-raw.c
@@ -30,9 +30,21 @@
 #ifndef EV_SYN /* 2.4 kernel headers */
 # define EV_SYN 0x00
 #endif
+#ifndef EV_CNT
+# define EV_CNT (EV_MAX+1)
+#endif
+#ifndef ABS_CNT
+# define ABS_CNT (ABS_MAX+1)
+#endif
+#ifndef KEY_CNT
+# define KEY_CNT (KEY_MAX+1)
+#endif
 
 #include "tslib-private.h"
 
+#define GRAB_EVENTS_WANTED	1
+#define GRAB_EVENTS_ACTIVE	2
+
 #define EV_VERSION_TSLIB	0x10000
 
 struct tslib_input {
@@ -44,29 +56,75 @@ struct tslib_input {
 
 	int	sane_fd;
 	int	using_syn;
+	int	grab_events;
 };
 
+#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
+#define BIT(nr)                 (1UL << (nr))
+#define BIT_MASK(nr)            (1UL << ((nr) % BITS_PER_LONG))
+#define BIT_WORD(nr)            ((nr) / BITS_PER_LONG)
+#define BITS_PER_BYTE           8
+#define BITS_PER_LONG           (sizeof(long) * BITS_PER_BYTE)
+#define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
+
 static int check_fd(struct tslib_input *i)
 {
 	struct tsdev *ts = i->module.dev;
 	int version;
-	u_int32_t bit;
-	u_int64_t absbit;
-
-	if (! ((ioctl(ts->fd, EVIOCGVERSION, &version) >= 0) &&
-		(version == EV_VERSION_TSLIB) &&
-		(ioctl(ts->fd, EVIOCGBIT(0, sizeof(bit) * 8), &bit) >= 0) &&
-		(bit & (1 << EV_ABS)) &&
-		(ioctl(ts->fd, EVIOCGBIT(EV_ABS, sizeof(absbit) * 8), &absbit) >= 0) &&
-		(absbit & (1 << ABS_X)) &&
-		(absbit & (1 << ABS_Y)) && (absbit & (1 << ABS_PRESSURE)))) {
-		fprintf(stderr, "selected device is not a touchscreen I understand\n");
+	long evbit[BITS_TO_LONGS(EV_CNT)];
+	long absbit[BITS_TO_LONGS(ABS_CNT)];
+	long keybit[BITS_TO_LONGS(KEY_CNT)];
+
+	if (ioctl(ts->fd, EVIOCGVERSION, &version) < 0) {
+		fprintf(stderr, "tslib: Selected device is not a Linux input event device\n");
+		return -1;
+	}
+
+	if (version > EV_VERSION_TSLIB) {
+		fprintf(stderr, "tslib: Selected device uses a different version of the event protocol than tslib was compiled for\n");
+		return -1;
+	}
+
+	if ( (ioctl(ts->fd, EVIOCGBIT(0, sizeof(evbit)), evbit) < 0) ||
+		!(evbit[BIT_WORD(EV_ABS)] & BIT_MASK(EV_ABS)) ||
+		!(evbit[BIT_WORD(EV_KEY)] & BIT_MASK(EV_KEY)) ) {
+		fprintf(stderr, "tslib: Selected device is not a touchscreen (must support ABS and KEY event types)\n");
 		return -1;
 	}
 
-	if (bit & (1 << EV_SYN))
+	if ((ioctl(ts->fd, EVIOCGBIT(EV_ABS, sizeof(absbit)), absbit)) < 0 ||
+		!(absbit[BIT_WORD(ABS_X)] & BIT_MASK(ABS_X)) ||
+		!(absbit[BIT_WORD(ABS_Y)] & BIT_MASK(ABS_Y))) {
+		fprintf(stderr, "tslib: Selected device is not a touchscreen (must support ABS_X and ABS_Y events)\n");
+		return -1;
+	}
+
+	/* Since some touchscreens (eg. infrared) physically can't measure pressure,
+	the input system doesn't report it on those. Tslib relies on pressure, thus
+	we set it to constant 255. It's still controlled by BTN_TOUCH - when not
+	touched, the pressure is forced to 0. */
+
+	if (!(absbit[BIT_WORD(ABS_PRESSURE)] & BIT_MASK(ABS_PRESSURE))) {
+		i->current_p = 255;
+
+		if ((ioctl(ts->fd, EVIOCGBIT(EV_KEY, sizeof(keybit)), keybit) < 0) ||
+			!(keybit[BIT_WORD(BTN_TOUCH)] & BIT_MASK(BTN_TOUCH)) ) {
+			fprintf(stderr, "tslib: Selected device is not a touchscreen (must support BTN_TOUCH events)\n");
+			return -1;
+		}
+	}
+
+	if (evbit[BIT_WORD(EV_SYN)] & BIT_MASK(EV_SYN))
 		i->using_syn = 1;
 
+	if (i->grab_events == GRAB_EVENTS_WANTED) {
+		if (ioctl(ts->fd, EVIOCGRAB, (void *)1)) {
+			fprintf(stderr, "tslib: Unable to grab selected input device\n");
+			return -1;
+		}
+		i->grab_events = GRAB_EVENTS_ACTIVE;
+	}
+
 	return 0;
 }
 
-- 
1.8.1.2

