From b70afb275f560c492150fd8726cea03d2f5fa354 Mon Sep 17 00:00:00 2001
From: Tom Salata <toms@tpi.com>
Date: Mon, 21 Aug 2023 10:11:19 -0700
Subject: [PATCH 1/1] drivers: touchscreen: evervision: Swap X and Y

Swap X and Y position for S001-011.

Signed-off-by: Tom Salata <toms@tpi.com>
---
 drivers/input/touchscreen/evervision.c | 326 +++++++++++++++++--------
 1 file changed, 221 insertions(+), 105 deletions(-)

diff --git a/drivers/input/touchscreen/evervision.c b/drivers/input/touchscreen/evervision.c
index ba533e050da5..b4101eb0418b 100644
--- a/drivers/input/touchscreen/evervision.c
+++ b/drivers/input/touchscreen/evervision.c
@@ -18,7 +18,6 @@
 #define DEV_NAME    		"evervision-i2c"
 
 #define NUM_FINGERS_SUPPORTED               10
-#define MSG_SIZE                            62
 
 #define X_MIN                               0x00
 #define Y_MIN                               0x00
@@ -33,6 +32,25 @@
 #define EVERVISION_ReadSendCMDgetCRCMsg            3
 #define EVERVISION_HandleTouchMsg                  4
 
+#define FT5426_PCAP
+
+#ifdef FT5426_PCAP
+// tweaked for microtips display with newer fT5xxx CA
+#define MSG_SIZE               63
+#define OFFSET_MODE		0
+#define OFFSET_GEST_ID	1
+#define OFFSET_STATUS	2
+#define OFFSET_PT0		3
+#define PT_STRIDE		6
+// these are relative to the point base (= stride * pt # + offset_p0)
+#define OFFSET_X_L		1
+#define OFFSET_Y_L		3
+#define OFFSET_X_H		0
+#define OFFSET_Y_H		2
+#define OFFSET_PRESSURE	4
+#define OFFSET_AREA		5
+#else
+#define MSG_SIZE               62
 #define OFFSET_CID		0
 #define OFFSET_STATUS	0
 #define OFFSET_X_L		1
@@ -41,9 +59,16 @@
 #define OFFSET_Y_H		3
 #define OFFSET_PRESSURE	4
 #define OFFSET_AREA		5
+#endif
 
 #define MULTITOUCH_INT_GPIO		MXS_PIN_ENCODE(0x2, 19) /* bank2 starts at 64 and this is pin 19*/
 
+#ifdef REACH_DBG
+#  define REACH_DBG_PRINT(s,...)  pr_devel("%s: " s, __func__, ##__VA_ARGS__)
+#else
+#  define REACH_DBG_PRINT(s,...)
+#endif // REACH_DBG
+
 struct point_data {
         short Status;
         short X;
@@ -79,7 +104,6 @@ struct evervision_data
 	int delta;
 };
 
-static int LastUpdateID = 0;
 static struct evervision_data *evervision_gpts = NULL;
 
 int      evervision_release(struct inode *, struct file *);
@@ -93,12 +117,16 @@ static int evervision_major = 0;
 
 int evervision_open(struct inode *inode, struct file *filp)
 {
+	REACH_DBG_PRINT("\n");
+
 	return 0;
 }
 EXPORT_SYMBOL(evervision_open);
 
 int  evervision_release(struct inode *inode, struct file *filp)
 {
+	REACH_DBG_PRINT("\n");
+
 	return 0;
 }
 EXPORT_SYMBOL(evervision_release);
@@ -108,6 +136,8 @@ ssize_t evervision_write(struct file *file, const char *buf, size_t count, loff_
 	int ret;
 	char *tmp;
 
+	REACH_DBG_PRINT("\n");
+
 	if (count > 8192)
 		count = 8192;
 
@@ -118,7 +148,7 @@ ssize_t evervision_write(struct file *file, const char *buf, size_t count, loff_
 		kfree(tmp);
 		return -EFAULT;
 	}
-	printk("writing %zu bytes.\n", count);
+	REACH_DBG_PRINT("writing %zu bytes.\n", count);
 
 	ret = i2c_master_send(evervision_gpts->client, tmp, count);
 	kfree(tmp);
@@ -131,6 +161,8 @@ ssize_t evervision_read(struct file *file, char *buf, size_t count, loff_t *ppos
 	char *tmp;
 	int ret;
 
+	REACH_DBG_PRINT("\n");
+
 	if (count > 8192)
 		count = 8192;
 
@@ -138,11 +170,11 @@ ssize_t evervision_read(struct file *file, char *buf, size_t count, loff_t *ppos
 	if (tmp==NULL)
 		return -ENOMEM;
 
-	printk("reading %zu bytes.\n", count);
+	REACH_DBG_PRINT("reading %zu bytes.\n", count);
 
 	ret = i2c_master_recv(evervision_gpts->client, tmp, count);
 	if (ret >= 0)
-		ret = copy_to_user(buf,tmp,count)?-EFAULT:ret;
+		ret = copy_to_user(buf,tmp,count) ? -EFAULT : ret;
 	kfree(tmp);
 	return ret;
 }
@@ -150,54 +182,103 @@ EXPORT_SYMBOL(evervision_read);
 
 long evervision_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
+	REACH_DBG_PRINT("\n");
+
 	return 0;
 }
 EXPORT_SYMBOL(evervision_ioctl);
 
 static inline int evervision_parser_packet(u8 *buff, struct evervision_data *evervision)
 {
-	int i, FID, POINTS;
-	short ContactID = -1;
-    int X, Y;
-    int EVENT;
-
-    POINTS = buff[2] & 0x0F;
-    Y = ((buff[3] & 0x0F) << 8) | (buff[4]);
-    X = ((buff[5] & 0x0F) << 8) | (buff[6]);
-    EVENT = (buff[3] & 0xC0) >> 6;
-
-    //printk("touches = %d (0x%02X) \n", POINTS, buff[2]);
-    //printk("event = %d (0x%02X) \n", EVENT, buff[3]);
-    //printk(" x=%d, y=%d \n\n", X,Y);
-
-    /* tslib only support a single touch */
-    switch (EVENT) {
-        case 0:
-        case 2:
-            input_report_abs(evervision->input, ABS_X, X);
-            input_report_abs(evervision->input, ABS_Y, Y);
-            input_report_abs(evervision->input, ABS_PRESSURE, 255);
-            input_sync(evervision->input);
-            break;
+	int POINTS;
+	int X, Y;
+	int EVENT;
+
+	REACH_DBG_PRINT("<-\n");
+
+#ifdef FT5426_PCAP
+	// updated for Microtips display with newer FT5426 PCAP chip
+	POINTS = buff[OFFSET_STATUS] & 0x0F;
+	X = ((buff[OFFSET_PT0 + OFFSET_X_H] & 0x0F) << 8) | (buff[OFFSET_PT0 + OFFSET_X_L]);
+	Y = ((buff[OFFSET_PT0 + OFFSET_Y_H] & 0x0F) << 8) | (buff[OFFSET_PT0 + OFFSET_Y_L]);
+	EVENT = (buff[OFFSET_PT0 + OFFSET_X_H] & 0xC0) >> 6;
+#else
+	POINTS = buff[2] & 0x0F;
+	Y = ((buff[3] & 0x0F) << 8) | (buff[4]);
+	X = ((buff[5] & 0x0F) << 8) | (buff[6]);
+	EVENT = (buff[3] & 0xC0) >> 6;
+#endif
+
+	REACH_DBG_PRINT("touches = %d (0x%02X)\n", POINTS, buff[2]);
+	REACH_DBG_PRINT("event = %d (0x%02X)\n", EVENT, buff[3]);
+	REACH_DBG_PRINT("x=%d, y=%d\n\n", X, Y);
+
+	/* tslib only support a single touch */
+	switch (EVENT) {
+	case 0:
+	case 2:
+		input_report_abs(evervision->input, ABS_X, X);
+		input_report_abs(evervision->input, ABS_Y, Y);
+		input_report_abs(evervision->input, ABS_PRESSURE, 255);
+		input_sync(evervision->input);
+		break;
+
         case 1:
-            input_report_abs(evervision->input, ABS_X, 0);
-            input_report_abs(evervision->input, ABS_Y, 0);
-            input_report_abs(evervision->input, ABS_PRESSURE, 0);
-            input_sync(evervision->input);
-            break;
+		input_report_abs(evervision->input, ABS_X, 0);
+		input_report_abs(evervision->input, ABS_Y, 0);
+		input_report_abs(evervision->input, ABS_PRESSURE, 0);
+		input_sync(evervision->input);
+		break;
+
         default:
-            printk("Invalid EVENT: %d \n", EVENT);
-    }
+		pr_err("%s: Invalid EVENT: %d\n", __func__, EVENT);
+        goto ERR_PACKET;
+		break;
+	}
+
+	REACH_DBG_PRINT("\n");
 
 	return 0;
 
 ERR_PACKET:
-	printk("ERR PACKET\n");
+	pr_err("ERR PACKET\n");
 	return -1;
 }
 
 static inline int evervision_read_block_onetime(struct i2c_client *client, u16 length, u8 *value)
 {
+	int rc = 0;
+
+	REACH_DBG_PRINT("len: %hd\n", length);
+
+#ifdef FT5426_PCAP
+	// updated for Microtips display with newer FT5426 PCAP chip
+	// buffer (i.e. *value)  initially has one 0 in it
+	// write that 1st
+	struct i2c_msg msgs[] = {
+		{
+			.addr 	= client->addr,
+			.flags 	= 0,
+			.len 	= 1,
+			.buf 	= value,
+		},
+		{
+			.addr 	= client->addr,
+			.flags 	= I2C_M_RD,
+			.len 	= length,
+			.buf 	= value,
+		},
+	};
+
+	rc = i2c_transfer(client->adapter, msgs, 2);
+	REACH_DBG_PRINT("rc: %d\n", rc);
+	if (rc < 0) {
+		pr_err("%s: i2c transfer failed\n", __func__);
+		return -1;
+	}
+
+	return rc;
+#else
 	struct evervision_data *evervision;
 	int rc = 0;
 
@@ -205,46 +286,56 @@ static inline int evervision_read_block_onetime(struct i2c_client *client, u16 l
 
 	rc = i2c_master_recv(evervision->client, value, length);
 
+	REACH_DBG_PRINT("rc: %d\n", rc);
+
 	if (rc == length) {
 		return length;
 	} else {
 		mdelay(10);
-		printk("Evervision: i2c read failed\n");
+		pr_err("Evervision: i2c read failed\n");
 		return -1;
-	}	
+	}
+#endif
 }
 
 static void evervision_worker(struct work_struct *work)
 {
-    struct evervision_data *evervision = container_of(work, struct evervision_data, work);
-    u8 buffer[MSG_SIZE] = {0}; 
-    int i;
-
-    if(evervision_read_block_onetime(evervision->client, MSG_SIZE, &buffer[0]) < 0) {
-       printk("Evervision: evervision_read_block failed, try again\n"); 
-    } 
-
-    #if 0 
-        for (i=0; i<MSG_SIZE; i++) {
-			if(i==0 || i==7 || i==14 || i==21 || i==28 || i==35 || i==42 || i==49 || i==56)
-				printk("\nfinger[%d] : ", (i/6)+1);
-			printk("0x%02x ", buffer[i]);
+	struct evervision_data *evervision = container_of(work, struct evervision_data, work);
+	u8 buffer[MSG_SIZE] = {0};
+#ifdef REACH_DBG
+	int i;
+#endif
+
+	REACH_DBG_PRINT("<-\n");
+
+	if (evervision_read_block_onetime(evervision->client, MSG_SIZE, &buffer[0]) < 0) {
+		pr_err("Evervision: evervision_read_block failed, try again\n");
+	}
+
+#ifdef REACH_DBG
+    for (i = 0; i < MSG_SIZE; i++) {
+        if ((i == 0) || (i == 7) || (i == 14) || (i == 21) || (i == 28) || (i == 35) || (i == 42) || (i == 49) || (i == 56)) {
+            printk("\n%s: finger[%d] ", __func__, (i / 6) + 1);
+        }
+        printk(", %02d: 0x%02x", i, buffer[i]);
     }
-    #endif
+#endif
+
+	evervision_parser_packet(buffer,evervision);
 
-    evervision_parser_packet(buffer,evervision);
+	enable_irq(gpio_to_irq(evervision->client->irq));
 
-    enable_irq(gpio_to_irq(evervision->client->irq));
+	REACH_DBG_PRINT("->\n");
 }
 
 static irqreturn_t evervision_irq_handler(int irq, void *dev_id)
 {
 	struct evervision_data *ts = dev_id;
 
-    //printk("%s: \n", __func__);
+	//REACH_DBG_PRINT("\n");
 
 	disable_irq_nosync(gpio_to_irq(ts->client->irq));
-    schedule_work(&ts->work);
+	schedule_work(&ts->work);
 
 	return IRQ_HANDLED;
 }
@@ -252,86 +343,112 @@ static irqreturn_t evervision_irq_handler(int irq, void *dev_id)
 
 static int evervision_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
-    struct evervision_data *evervision;
-    int error = 0;
-    int ret = 0; 
-    uint16_t max_x = 0, max_y = 0;
-
-    printk("%s: \n", __func__);
-    
-    evervision = kzalloc(sizeof(struct evervision_data), GFP_KERNEL);
-    if (evervision == NULL) {
-		printk("Evervision: insufficient memory\n");
+	struct evervision_data *evervision;
+	int error = 0;
+	int ret = 0;
+	uint16_t max_x = 0, max_y = 0;
+
+	REACH_DBG_PRINT("\n");
+
+	REACH_DBG_PRINT("client.name: %s\n", client->name);
+	REACH_DBG_PRINT("client.addr: %hx\n", client->addr);
+	REACH_DBG_PRINT("client.flags: %hx\n", client->flags);
+	REACH_DBG_PRINT("client.irq: %x\n", client->irq);
+
+	evervision = kzalloc(sizeof(struct evervision_data), GFP_KERNEL);
+	if (evervision == NULL) {
+		pr_err("Evervision: insufficient memory\n");
 		error = -ENOMEM;
 		goto err_evervision_alloc;
 	}
-    
-    INIT_WORK(&evervision->work, evervision_worker);
-    evervision->client = client;
-    i2c_set_clientdata(client, evervision);  
+
+	INIT_WORK(&evervision->work, evervision_worker);
+	evervision->client = client;
+	i2c_set_clientdata(client, evervision);
 
    	ret = request_irq(gpio_to_irq(client->irq), evervision_irq_handler, IRQF_TRIGGER_FALLING | IRQF_DISABLED, client->name, evervision);
 	if (ret == 0)
-        printk("%s: using IRQ \n", __func__);
+		REACH_DBG_PRINT("using IRQ\n");
 	else
-	    dev_err(&client->dev, "request_irq failed\n");
+		dev_err(&client->dev, "request_irq failed\n");
+
+	evervision_gpts = kzalloc(sizeof(*evervision), GFP_KERNEL);
+	if (evervision_gpts == NULL) {
+		pr_err("Evervision: insufficient memory\n");
+		error = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
 
-    evervision_gpts = kzalloc(sizeof(*evervision), GFP_KERNEL);
-     
-    evervision->input = input_allocate_device();
-	if (evervision->input == NULL){
+	evervision->input = input_allocate_device();
+	if (evervision->input == NULL) {
 		ret = -ENOMEM;
 		goto err_input_dev_alloc_failed;
 	}
 
-    evervision->input->name = "evervision-ts";
-    set_bit(EV_KEY, evervision->input->evbit);
+	evervision->input->name = "evervision-ts";
+	set_bit(EV_KEY, evervision->input->evbit);
 	set_bit(BTN_TOUCH, evervision->input->keybit);
 	set_bit(EV_ABS, evervision->input->evbit);
 
    	max_x = evervision->x_range;
 	max_y = evervision->y_range;
- 
-    __set_bit(ABS_X, evervision->input->absbit);
+
+	__set_bit(ABS_X, evervision->input->absbit);
 	__set_bit(ABS_Y, evervision->input->absbit);
 
-    input_set_abs_params(evervision->input, ABS_X, 0, max_x, 0, 0);
+	input_set_abs_params(evervision->input, ABS_X, 0, max_x, 0, 0);
 	input_set_abs_params(evervision->input, ABS_Y, 0, max_y, 0, 0);
-    input_set_abs_params(evervision->input, ABS_PRESSURE, 0, 10, 0, 0);
+	input_set_abs_params(evervision->input, ABS_PRESSURE, 0, 10, 0, 0);
 
-    if(input_register_device(evervision->input)){
-		printk("Can not register input device.");
+	if (input_register_device(evervision->input)) {
+		pr_err("Can not register input device.");
 		goto err_input_register_device_failed;
 	}
-  
- 
-    return 0;
+
+	REACH_DBG_PRINT("->\n");
+
+	return 0;
 err_input_register_device_failed:
 	input_free_device(evervision->input);
 err_evervision_alloc:
 	return error;
 
 err_input_dev_alloc_failed:
-    kfree(evervision);
+    if (evervision_gpts != NULL) {
+        kfree(evervision_gpts);
+        evervision_gpts = NULL;
+    }
+
+    if (evervision != NULL) {
+        kfree(evervision);
+        evervision = NULL;
+    }
 
-    return ret;
+	return ret;
 }
 
 static int evervision_remove(struct i2c_client *client)
 {
 	struct evervision_data *evervision;
 
-    printk("%s: \n", __func__);
+	REACH_DBG_PRINT("\n");
 
 	evervision = i2c_get_clientdata(client);
 
+    if (evervision_gpts != NULL) {
+        kfree(evervision_gpts);
+        evervision_gpts = NULL;
+    }
+
 	if (evervision != NULL) {
 		if (evervision->irq)
     	    free_irq(gpio_to_irq(client->irq), evervision);
 
 		input_unregister_device(evervision->input);
+
+        kfree(evervision);
+        evervision = NULL;
 	}
-	kfree(evervision);
 	i2c_set_clientdata(client, NULL);
 
 	return 0;
@@ -368,19 +485,20 @@ static int __devinit evervision_init(void)
 	int err = 0;
 	dev_t devno = MKDEV(evervision_major, 0);
 
-    printk("%s: \n", __func__);
-	result  = alloc_chrdev_region(&devno, 0, 1, DEV_NAME);
-	if(result < 0){
-		printk("fail to allocate chrdev (%d) \n", result);
+	REACH_DBG_PRINT("\n");
+
+	result = alloc_chrdev_region(&devno, 0, 1, DEV_NAME);
+	if (result < 0) {
+		pr_err("Failed to allocate chrdev (%d)\n", result);
 		return 0;
 	}
 	evervision_major = MAJOR(devno);
-        cdev_init(&evervision_cdev, &nc_fops);
+    cdev_init(&evervision_cdev, &nc_fops);
 	evervision_cdev.owner = THIS_MODULE;
 	evervision_cdev.ops = &nc_fops;
-        err =  cdev_add(&evervision_cdev, devno, 1);
-	if(err){
-		printk("fail to add cdev (%d) \n", err);
+    err =  cdev_add(&evervision_cdev, devno, 1);
+	if (err) {
+		pr_err("Failed to add cdev (%d)\n", err);
 		return 0;
 	}
 
@@ -388,29 +506,27 @@ static int __devinit evervision_init(void)
 	if (IS_ERR(evervision_class)) {
 		result = PTR_ERR(evervision_class);
 		unregister_chrdev(evervision_major, DEV_NAME);
-		printk("fail to create class (%d) \n", result);
+		pr_err("Failed to create class (%d)\n", result);
 		return result;
 	}
 	device_create(evervision_class, NULL, MKDEV(evervision_major, 0), NULL, DEV_NAME);
- 
 
 	return i2c_add_driver(&evervision_driver);
 }
 
 static void __exit evervision_exit(void)
 {
-    dev_t dev_id = MKDEV(evervision_major, 0);
+	dev_t dev_id = MKDEV(evervision_major, 0);
 
-    printk("%s: \n", __func__);
+	REACH_DBG_PRINT("\n");
 
 	i2c_del_driver(&evervision_driver);
 
-    cdev_del(&evervision_cdev);
+	cdev_del(&evervision_cdev);
 
 	device_destroy(evervision_class, dev_id); //delete device node under /dev
 	class_destroy(evervision_class); //delete class created by us
 	unregister_chrdev_region(dev_id, 1);
-
 }
 
 module_init(evervision_init);
-- 
2.25.1

